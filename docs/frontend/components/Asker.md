# Asker ç»„ä»¶

> **ç»„ä»¶åç§°**: Asker (AI é—®ç­”å¯¹è¯ç»„ä»¶)
> **çŠ¶æ€**: ğŸš§ å¼€å‘ä¸­
> **æœ€åæ›´æ–°**: 2026-02-04

---

## ğŸ“‹ æ¦‚è¿°

Asker ç»„ä»¶æ˜¯ FloatingOrb çš„**ç‚¹å‡»æ€**ï¼Œå½“ç”¨æˆ·ç‚¹å‡»æ‚¬æµ®çƒæ—¶å±•å¼€ï¼Œæä¾›åŸºäºå‘é‡æœç´¢çš„è®°å¿†é—®ç­”åŠŸèƒ½ã€‚æ”¯æŒå¤šè½®å¯¹è¯ï¼Œå¸®åŠ©ç”¨æˆ·å¿«é€Ÿæ£€ç´¢å’Œç†è§£å†å²è®°å¿†ã€‚

---

## ğŸ¨ UI è®¾è®¡

### è§†è§‰è§„èŒƒ

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        Asker é—®ç­”ç•Œé¢å¸ƒå±€              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ğŸ¤– Vision-Jarvis è®°å¿†åŠ©æ‰‹     [Ã—]  â”‚ â† Header
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                     â”‚
â”‚  ğŸ’¬ å¯¹è¯å†å²åŒºåŸŸ                     â”‚
â”‚                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ ğŸ‘¤ æˆ‘: ä¸Šåˆåšäº†ä»€ä¹ˆ?          â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ ğŸ¤– AI: æ‚¨ä¸Šåˆä¸»è¦è¿›è¡Œäº†ä»¥ä¸‹   â”‚ â”‚
â”‚  â”‚      æ´»åŠ¨ï¼š                   â”‚ â”‚
â”‚  â”‚      1. 09:00-10:00 å›¢é˜Ÿæ™¨ä¼š  â”‚ â”‚
â”‚  â”‚      2. 10:15-11:30 ä»£ç å¼€å‘  â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â† Input Area
â”‚  â”‚ è¾“å…¥æ¡†...              [å‘é€] â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

å°ºå¯¸:
- å®½åº¦: 400px
- é«˜åº¦: 500px
- åœ†è§’: 16px

èƒŒæ™¯:
- èƒŒæ™¯è‰²: #ffffff (äº®è‰²) / #1f2937 (æš—è‰²)
- é˜´å½±: 0 20px 40px rgba(0,0,0,0.3)

å¸ƒå±€:
- Header: 60px
- Chat Area: flex-1 (auto)
- Input Area: 80px
```

---

## ğŸ”§ ç»„ä»¶ API

### Props

```typescript
interface AskerProps {
  /** å…³é—­å›è°ƒ */
  onClose?: () => void;

  /** åˆå§‹å¯¹è¯å†å² */
  initialMessages?: Message[];

  /** æ˜¯å¦æ˜¾ç¤ºæ¬¢è¿æ¶ˆæ¯ */
  showWelcome?: boolean;

  /** è‡ªå®šä¹‰å ä½ç¬¦æ–‡æœ¬ */
  placeholder?: string;

  /** æœ€å¤§é«˜åº¦ */
  maxHeight?: number;

  /** è‡ªå®šä¹‰ç±»å */
  className?: string;
}

interface Message {
  id: string;
  role: 'user' | 'assistant';
  content: string;
  timestamp: Date;
}
```

### é»˜è®¤å€¼

```typescript
const defaultProps: AskerProps = {
  onClose: undefined,
  initialMessages: [],
  showWelcome: true,
  placeholder: 'é—®æˆ‘ä»»ä½•è®°å¿†ç›¸å…³çš„é—®é¢˜...',
  maxHeight: 500,
  className: ''
};
```

---

## ğŸ’» ä½¿ç”¨ç¤ºä¾‹

### åŸºç¡€ç”¨æ³•

```typescript
// components/FloatingOrb/FloatingOrb.tsx
import { Asker } from './Asker';

export function FloatingOrb() {
  const [state, setState] = useState<'idle' | 'header' | 'asker'>('idle');

  const handleClose = () => {
    setState('idle');
  };

  return (
    <>
      {state === 'asker' && <Asker onClose={handleClose} />}
    </>
  );
}
```

### å¸¦åˆå§‹æ¶ˆæ¯

```typescript
const initialMessages: Message[] = [
  {
    id: '1',
    role: 'assistant',
    content: 'ä½ å¥½ï¼æˆ‘æ˜¯ Vision-Jarvis è®°å¿†åŠ©æ‰‹ï¼Œæœ‰ä»€ä¹ˆå¯ä»¥å¸®ä½ çš„å—ï¼Ÿ',
    timestamp: new Date()
  }
];

<Asker
  initialMessages={initialMessages}
  showWelcome={false}
  onClose={handleClose}
/>
```

---

## ğŸ—ï¸ å†…éƒ¨å®ç°

### ç»„ä»¶ç»“æ„

```typescript
// components/FloatingOrb/Asker.tsx
import { useState, useRef, useEffect } from 'react';
import { motion } from 'framer-motion';
import { invoke } from '@tauri-apps/api/core';
import { FloatingInput } from '@/components/FloatingInput';
import { ChatMessage } from './ChatMessage';
import type { FC } from 'react';

export const Asker: FC<AskerProps> = ({
  onClose,
  initialMessages = [],
  showWelcome = true,
  placeholder = 'é—®æˆ‘ä»»ä½•è®°å¿†ç›¸å…³çš„é—®é¢˜...',
  maxHeight = 500,
  className = ''
}) => {
  const [messages, setMessages] = useState<Message[]>(
    showWelcome
      ? [
          {
            id: 'welcome',
            role: 'assistant',
            content: 'ä½ å¥½ï¼æˆ‘èƒ½å¸®ä½ æ£€ç´¢å’Œåˆ†æå†å²è®°å¿†ï¼Œè¯·é—®æœ‰ä»€ä¹ˆé—®é¢˜å—ï¼Ÿ',
            timestamp: new Date()
          },
          ...initialMessages
        ]
      : initialMessages
  );
  const [isLoading, setIsLoading] = useState(false);
  const chatEndRef = useRef<HTMLDivElement>(null);

  // è‡ªåŠ¨æ»šåŠ¨åˆ°åº•éƒ¨
  useEffect(() => {
    chatEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  }, [messages]);

  // å‘é€æ¶ˆæ¯
  const handleSendMessage = async (content: string) => {
    if (!content.trim()) return;

    // æ·»åŠ ç”¨æˆ·æ¶ˆæ¯
    const userMessage: Message = {
      id: Date.now().toString(),
      role: 'user',
      content,
      timestamp: new Date()
    };
    setMessages((prev) => [...prev, userMessage]);

    // è°ƒç”¨ AI æ¥å£
    setIsLoading(true);
    try {
      const response = await invoke<string>('ask_memory', {
        query: content,
        history: messages
      });

      // æ·»åŠ  AI å›å¤
      const aiMessage: Message = {
        id: (Date.now() + 1).toString(),
        role: 'assistant',
        content: response,
        timestamp: new Date()
      };
      setMessages((prev) => [...prev, aiMessage]);
    } catch (error) {
      console.error('Failed to ask memory:', error);

      // æ·»åŠ é”™è¯¯æ¶ˆæ¯
      const errorMessage: Message = {
        id: (Date.now() + 1).toString(),
        role: 'assistant',
        content: 'æŠ±æ­‰ï¼ŒæŸ¥è¯¢è®°å¿†æ—¶å‡ºç°é”™è¯¯ï¼Œè¯·ç¨åå†è¯•ã€‚',
        timestamp: new Date()
      };
      setMessages((prev) => [...prev, errorMessage]);
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <motion.div
      className={`asker ${className}`}
      initial={{ y: 100, opacity: 0 }}
      animate={{ y: 0, opacity: 1 }}
      exit={{ y: 100, opacity: 0 }}
      transition={{ duration: 0.4, ease: 'easeOut' }}
      style={{
        width: '400px',
        maxHeight: `${maxHeight}px`,
        borderRadius: '16px',
        background: '#ffffff',
        boxShadow: '0 20px 40px rgba(0, 0, 0, 0.3)',
        display: 'flex',
        flexDirection: 'column',
        overflow: 'hidden'
      }}
    >
      {/* Header */}
      <div className="asker-header">
        <div className="flex items-center gap-2">
          <span className="text-2xl">ğŸ¤–</span>
          <h3 className="text-lg font-semibold">è®°å¿†åŠ©æ‰‹</h3>
        </div>
        <button
          onClick={onClose}
          className="close-btn"
          aria-label="å…³é—­"
        >
          Ã—
        </button>
      </div>

      {/* Chat Area */}
      <div className="asker-chat-area">
        {messages.map((message) => (
          <ChatMessage key={message.id} message={message} />
        ))}
        {isLoading && (
          <div className="loading-indicator">
            <span className="dot"></span>
            <span className="dot"></span>
            <span className="dot"></span>
          </div>
        )}
        <div ref={chatEndRef} />
      </div>

      {/* Input Area */}
      <FloatingInput
        placeholder={placeholder}
        onSend={handleSendMessage}
        disabled={isLoading}
      />
    </motion.div>
  );
};
```

### ChatMessage å­ç»„ä»¶

```typescript
// components/FloatingOrb/ChatMessage.tsx
import { motion } from 'framer-motion';
import { formatTime } from '@/utils/time';

interface ChatMessageProps {
  message: Message;
}

export function ChatMessage({ message }: ChatMessageProps) {
  const isUser = message.role === 'user';

  return (
    <motion.div
      className={`chat-message ${isUser ? 'user' : 'assistant'}`}
      initial={{ opacity: 0, y: 10 }}
      animate={{ opacity: 1, y: 0 }}
      transition={{ duration: 0.3 }}
    >
      <div className="message-avatar">
        {isUser ? 'ğŸ‘¤' : 'ğŸ¤–'}
      </div>
      <div className="message-content">
        <p className="message-text">{message.content}</p>
        <span className="message-time">
          {formatTime(message.timestamp)}
        </span>
      </div>
    </motion.div>
  );
}
```

---

## ğŸ¬ åŠ¨ç”»æ•ˆæœ

### å…¥åœºåŠ¨ç”»

```typescript
const askerAnimation = {
  initial: { y: 100, opacity: 0, scale: 0.95 },
  animate: {
    y: 0,
    opacity: 1,
    scale: 1,
    transition: {
      duration: 0.4,
      ease: 'easeOut'
    }
  },
  exit: {
    y: 100,
    opacity: 0,
    scale: 0.95,
    transition: {
      duration: 0.3,
      ease: 'easeIn'
    }
  }
};
```

### æ¶ˆæ¯åŠ¨ç”»

```typescript
const messageAnimation = {
  initial: { opacity: 0, y: 10 },
  animate: {
    opacity: 1,
    y: 0,
    transition: {
      duration: 0.3,
      ease: 'easeOut'
    }
  }
};
```

### åŠ è½½åŠ¨ç”»

```css
/* Loading dots animation */
.loading-indicator {
  display: flex;
  gap: 4px;
  padding: 16px;
}

.dot {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  background: #667eea;
  animation: bounce 1.4s infinite ease-in-out both;
}

.dot:nth-child(1) {
  animation-delay: -0.32s;
}

.dot:nth-child(2) {
  animation-delay: -0.16s;
}

@keyframes bounce {
  0%, 80%, 100% {
    transform: scale(0);
  }
  40% {
    transform: scale(1);
  }
}
```

---

## ğŸ”— åç«¯é›†æˆ

### Tauri Command è°ƒç”¨

```typescript
// å‘é‡æœç´¢é—®ç­”
async function askMemory(query: string, history: Message[]) {
  try {
    const response = await invoke<string>('ask_memory', {
      query,
      history: history.map(m => ({
        role: m.role,
        content: m.content
      }))
    });
    return response;
  } catch (error) {
    throw new Error(`Failed to ask memory: ${error}`);
  }
}
```

### Rust åç«¯ç¤ºä¾‹

```rust
// src-tauri/src/commands/memory.rs
#[tauri::command]
pub async fn ask_memory(
    query: String,
    history: Vec<ChatMessage>,
    state: State<'_, AppState>,
) -> Result<String, String> {
    // 1. å‘é‡æœç´¢ç›¸å…³è®°å¿†
    let memories = state.vector_db
        .search(&query, 5)
        .await
        .map_err(|e| e.to_string())?;

    // 2. æ„å»º AI æç¤ºè¯
    let context = format_memories_context(&memories);
    let prompt = build_prompt(&query, &context, &history);

    // 3. è°ƒç”¨ AI API
    let response = state.ai_client
        .chat(&prompt)
        .await
        .map_err(|e| e.to_string())?;

    Ok(response)
}
```

---

## ğŸ“± å“åº”å¼è®¾è®¡

```typescript
// æ ¹æ®å±å¹•å°ºå¯¸è°ƒæ•´å¸ƒå±€
const getAskerLayout = () => {
  const width = window.innerWidth;
  const height = window.innerHeight;

  if (width < 768) {
    return {
      width: '320px',
      maxHeight: `${Math.min(height - 100, 400)}px`
    };
  }

  if (width < 1024) {
    return {
      width: '360px',
      maxHeight: `${Math.min(height - 100, 450)}px`
    };
  }

  return {
    width: '400px',
    maxHeight: `${Math.min(height - 100, 500)}px`
  };
};
```

---

## â™¿ å¯è®¿é—®æ€§

### é”®ç›˜å¯¼èˆª

```typescript
// æ”¯æŒ ESC é”®å…³é—­
useEffect(() => {
  const handleKeyDown = (e: KeyboardEvent) => {
    if (e.key === 'Escape') {
      onClose?.();
    }
  };

  window.addEventListener('keydown', handleKeyDown);
  return () => window.removeEventListener('keydown', handleKeyDown);
}, [onClose]);

// æ”¯æŒ Enter å‘é€æ¶ˆæ¯
<input
  onKeyDown={(e) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      handleSend();
    }
  }}
/>
```

### ARIA æ ‡ç­¾

```typescript
<div
  role="dialog"
  aria-label="è®°å¿†é—®ç­”å¯¹è¯æ¡†"
  aria-modal="true"
>
  <div
    role="log"
    aria-live="polite"
    aria-relevant="additions"
  >
    {/* å¯¹è¯å†å² */}
  </div>
</div>
```

---

## ğŸ§ª æµ‹è¯•

### å•å…ƒæµ‹è¯•

```typescript
// components/FloatingOrb/Asker.test.tsx
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { Asker } from './Asker';
import { vi } from 'vitest';

// Mock Tauri invoke
vi.mock('@tauri-apps/api/core', () => ({
  invoke: vi.fn()
}));

describe('Asker', () => {
  it('renders welcome message by default', () => {
    render(<Asker />);
    expect(screen.getByText(/ä½ å¥½/)).toBeInTheDocument();
  });

  it('sends message and displays response', async () => {
    const { invoke } = await import('@tauri-apps/api/core');
    (invoke as any).mockResolvedValue('è¿™æ˜¯ AI çš„å›å¤');

    render(<Asker />);

    const input = screen.getByPlaceholderText(/é—®æˆ‘ä»»ä½•/);
    const sendBtn = screen.getByText('å‘é€');

    fireEvent.change(input, { target: { value: 'ä¸Šåˆåšäº†ä»€ä¹ˆ?' } });
    fireEvent.click(sendBtn);

    await waitFor(() => {
      expect(screen.getByText('ä¸Šåˆåšäº†ä»€ä¹ˆ?')).toBeInTheDocument();
      expect(screen.getByText('è¿™æ˜¯ AI çš„å›å¤')).toBeInTheDocument();
    });
  });

  it('calls onClose when close button is clicked', () => {
    const handleClose = vi.fn();
    render(<Asker onClose={handleClose} />);

    fireEvent.click(screen.getByLabelText('å…³é—­'));
    expect(handleClose).toHaveBeenCalled();
  });
});
```

---

## ğŸ“ å¾…å®ç°åŠŸèƒ½

- [ ] æ¶ˆæ¯å¼•ç”¨åŠŸèƒ½ï¼ˆç‚¹å‡»è®°å¿†å¡ç‰‡è·³è½¬è¯¦æƒ…ï¼‰
- [ ] æ¶ˆæ¯ç¼–è¾‘å’Œåˆ é™¤
- [ ] å¯¼å‡ºå¯¹è¯å†å²
- [ ] è¯­éŸ³è¾“å…¥æ”¯æŒ
- [ ] ä»£ç é«˜äº®æ˜¾ç¤º
- [ ] Markdown æ¸²æŸ“
- [ ] æ¶ˆæ¯æœç´¢åŠŸèƒ½
- [ ] å¯¹è¯åˆ†æ”¯åŠŸèƒ½

---

## ğŸ”— ç›¸å…³ç»„ä»¶

- [FloatingOrb](FloatingOrb.md) - çˆ¶ç»„ä»¶
- [FloatingInput](FloatingInput.md) - è¾“å…¥æ¡†ç»„ä»¶
- [Header](Header.md) - Header ç»„ä»¶

---

## ğŸ“š å‚è€ƒèµ„æ–™

- [ChatGPT UI Design](https://chat.openai.com/)
- [Framer Motion Variants](https://www.framer.com/motion/animation/#variants)
- [React useRef for Scroll](https://react.dev/reference/react/useRef)

---

**ç»„ä»¶ç»´æŠ¤è€…**: å‰ç«¯å›¢é˜Ÿ
**æµ‹è¯•è¦†ç›–ç‡**: 0% (å¾…å¼€å‘)
**æœ€åæ›´æ–°**: 2026-02-04
